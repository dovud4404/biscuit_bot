#!/usr/bin/env python3
import os
import re
import html
import logging

from flask import Flask, request, abort
from telegram import Bot, Update, ReplyKeyboardRemove, ParseMode
from telegram.ext import (
    Dispatcher,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    filters,
    ContextTypes,
)

# â”€â”€â”€ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)

BOT_TOKEN      = os.environ["BOT_TOKEN"]
GROUP_CHAT_ID  = int(os.environ["GROUP_CHAT_ID"])
EXTERNAL_URL   = os.environ["RENDER_EXTERNAL_URL"].rstrip("/")  # https://â€¦onrender.com

PHONE_RE       = re.compile(r"^\+?\d[\d\s\-\(\)]{7,}$")
NAME, PHONE, COMMENT = range(3)

# â”€â”€â”€ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Flask-Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¸ Telegram-Ğ±Ğ¾Ñ‚Ğ° â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = Flask(__name__)
bot = Bot(BOT_TOKEN)
dp = Dispatcher(bot, None, workers=0, use_context=True)  # Ğ¾Ğ´Ğ¸Ğ½ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ

# â”€â”€â”€ Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text(
        "ğŸ° Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ! Ğ¯ Ğ¿Ñ€Ğ¸Ğ¼Ñƒ Ğ²Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ½Ğ° Ñ‚Ğ¾Ñ€Ñ‚.\n"
        "ĞšĞ°Ğº Ğ²Ğ°Ñ Ğ·Ğ¾Ğ²ÑƒÑ‚?",
        reply_markup=ReplyKeyboardRemove()
    )
    return NAME

async def ask_phone(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["name"] = update.message.text.strip()
    await update.message.reply_text("ğŸ“ Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:")
    return PHONE

async def ask_comment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    phone = update.message.text.strip()
    if not PHONE_RE.fullmatch(phone):
        await update.message.reply_text("â— ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ğ½Ğ¾Ğ¼ĞµÑ€, Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·:")
        return PHONE
    context.user_data["phone"] = phone
    await update.message.reply_text(
        "ğŸ’¬ Ğ’Ğ°Ñˆ ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹ (Ğ²ĞºÑƒÑ, Ğ²ĞµÑ, Ğ´Ğ°Ñ‚Ğ°) Ğ¸Ğ»Ğ¸ Â«-Â» ĞµÑĞ»Ğ¸ Ğ±ĞµĞ·:"
    )
    return COMMENT

async def finish(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    d = context.user_data
    d["comment"] = update.message.text.strip()

    # Ğ­ĞºÑ€Ğ°Ğ½Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¸Ğ¹ Ğ²Ğ²Ğ¾Ğ´
    name    = html.escape(d["name"])
    phone   = html.escape(d["phone"])
    comment = html.escape(d["comment"])

    text = (
        "ğŸ‚ <b>ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· Ñ‚Ğ¾Ñ€Ñ‚Ğ°!</b>\n\n"
        f"<b>Ğ˜Ğ¼Ñ:</b> {name}\n"
        f"<b>Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½:</b> {phone}\n"
        f"<b>ĞšĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸Ğ¹:</b> {comment}"
    )
    await bot.send_message(chat_id=GROUP_CHAT_ID, text=text, parse_mode=ParseMode.HTML)
    await update.message.reply_text("Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚ âœ…")
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("ĞÑ‚Ğ¼ĞµĞ½ĞµĞ½Ğ¾. /start â€” Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾.")
    return ConversationHandler.END

# Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ ConversationHandler
conv = ConversationHandler(
    entry_points=[CommandHandler("start", start)],
    states={
        NAME:    [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_phone)],
        PHONE:   [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_comment)],
        COMMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, finish)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
)
dp.add_handler(conv)

# â”€â”€â”€ Webhook Ğ¸ healthcheck â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.before_first_request
def setup_webhook():
    url = f"{EXTERNAL_URL}/{BOT_TOKEN}"
    logging.info("Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ webhook â†’ %s", url)
    bot.set_webhook(url)

@app.route(f"/{BOT_TOKEN}", methods=["POST"])
def webhook():
    data = request.get_json(force=True)
    update = Update.de_json(data, bot)
    dp.process_update(update)
    return "OK"

@app.route("/health", methods=["GET"])
def health():
    return "OK", 200

# â”€â”€â”€ Ğ—Ğ°Ğ¿ÑƒÑĞº â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    port = int(os.environ.get("PORT", "8443"))
    app.run(host="0.0.0.0", port=port)
